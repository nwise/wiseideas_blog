{"version":3,"sources":["node_modules/phoenix/priv/static/phoenix.js","node_modules/phoenix_html/priv/static/phoenix_html.js","deps/phoenix/web/static/js/phoenix.js","web/static/js/app.js","web/static/js/socket.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmJA,IAAM,MAAM,OAAZ;AACA,IAAM,gBAAgB,EAAC,YAAY,CAAb,EAAgB,MAAM,CAAtB,EAAyB,SAAS,CAAlC,EAAqC,QAAQ,CAA7C,EAAtB;AACA,IAAM,kBAAkB,KAAxB;AACA,IAAM,iBAAiB;AACrB,UAAQ,QADa;AAErB,WAAS,SAFY;AAGrB,UAAQ,QAHa;AAIrB,WAAS,SAJY;AAKrB,WAAS;AALY,CAAvB;AAOA,IAAM,iBAAiB;AACrB,SAAO,WADc;AAErB,SAAO,WAFc;AAGrB,QAAM,UAHe;AAIrB,SAAO,WAJc;AAKrB,SAAO;AALc,CAAvB;AAOA,IAAM,aAAa;AACjB,YAAU,UADO;AAEjB,aAAW;AAFM,CAAnB;;IAKM,I;;;;;;;;;;AASJ,gBAAY,OAAZ,EAAqB,K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","file":"priv/static/js/app.js","sourcesContent":["require.register('phoenix', function(exports,req,module){\n    var require = __makeRequire((function(n) { return req(n.replace('./', 'phoenix/')); }), {});\n    (function(exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are mulitplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket(\"/ws\", {params: {userToken: \"123\"}})\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket,\n// the authentication params, as well as options that can be found in\n// the Socket docs, such as configuring the `LongPoll` transport, and\n// heartbeat.\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here's an example chat room example where `\"new_msg\"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error/timeout matches:\n//\n//     let channel = socket.channel(\"rooms:123\", {token: roomToken})\n//     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n//     $input.onEnter( e => {\n//       channel.push(\"new_msg\", {body: e.target.val}, 10000)\n//        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n//        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n//        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n//     })\n//     channel.join()\n//       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n//       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n//       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\n//\n//\n// ## Joining\n//\n// Creating a channel with `socket.channel(topic, params)`, binds the params to\n// `channel.params`, which are sent up on `channel.join()`.\n// Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an \"ok\" status, while unsuccessful joins\n// receive \"error\".\n//\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `channel.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n//  and take action after some period of waiting. The default timeout is 5000ms.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\n//     socket.onClose( () => console.log(\"the connection dropped\") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     channel.onError( () => console.log(\"there was an error!\") )\n//     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attemtped\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `channel.leave()`\n//\n\nvar VSN = \"1.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 10000;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\n\nvar Push = function () {\n\n  // Initializes the Push\n  //\n  // channel - The Channel\n  // event - The event, for example `\"phx_join\"`\n  // payload - The payload, for example `{user_id: 123}`\n  // timeout - The push timeout in milliseconds\n  //\n\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref\n      });\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({ status: status, callback: callback });\n      return this;\n    }\n\n    // private\n\n  }, {\n    key: \"matchReceive\",\n    value: function matchReceive(_ref) {\n      var status = _ref.status;\n      var response = _ref.response;\n      var ref = _ref.ref;\n\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"cancelRefEvent\",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel.off(this.refEvent);\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n        _this.cancelTimeout();\n        _this.receivedResp = payload;\n        _this.matchReceive(payload);\n      });\n\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"hasReceived\",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, { status: status, response: response });\n    }\n  }]);\n\n  return Push;\n}();\n\nvar Channel = exports.Channel = function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this2.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this2.state = CHANNEL_STATES.joined;\n      _this2.rejoinTimer.reset();\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this2.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this2.socket.log(\"channel\", \"close \" + _this2.topic);\n      _this2.state = CHANNEL_STATES.closed;\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      _this2.socket.log(\"channel\", \"error \" + _this2.topic, reason);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (_this2.state !== CHANNEL_STATES.joining) {\n        return;\n      }\n\n      _this2.socket.log(\"channel\", \"timeout \" + _this2.topic, _this2.joinPush.timeout);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      if (this.joinedOnce) {\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n      }\n      this.rejoin(timeout);\n      return this.joinPush;\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({ event: event, callback: callback });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.timeout : arguments[2];\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use channel.join() before pushing events\";\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    // Leaves the channel\n    //\n    // Unsubscribes from server events, and\n    // instructs channel to terminate on server\n    //\n    // Triggers onClose() hooks\n    //\n    // To receive leave acknowledgements, use the a `receive`\n    // hook to bind to the server ack, ie:\n    //\n    //     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n    //\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      var onClose = function onClose() {\n        _this3.socket.log(\"channel\", \"leave \" + _this3.topic);\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    // Overridable message hook\n    //\n    // Receives all events for specialized message handling\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {}\n\n    // private\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(triggerEvent, payload, ref) {\n      this.onMessage(triggerEvent, payload, ref);\n      this.bindings.filter(function (bind) {\n        return bind.event === triggerEvent;\n      }).map(function (bind) {\n        return bind.callback(payload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\" + ref;\n    }\n  }]);\n\n  return Channel;\n}();\n\nvar Socket = exports.Socket = function () {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\n  //                                               \"wss://example.com\"\n  //                                               \"/ws\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n  //               Defaults to WebSocket with automatic LongPoll fallback.\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n\n  function Socket(endPoint) {\n    var _this4 = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || window.WebSocket || LongPoll;\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = endPoint + \"/\" + TRANSPORTS.websocket;\n    this.reconnectTimer = new Timer(function () {\n      _this4.disconnect(function () {\n        return _this4.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: \"protocol\",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n      if (uri.charAt(1) === \"/\") {\n        return this.protocol() + \":\" + uri;\n      }\n\n      return this.protocol() + \"://\" + location.host + uri;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n      }\n      callback && callback();\n    }\n\n    // params - The params to send when connecting, for example `{user_id: userToken}`\n\n  }, {\n    key: \"connect\",\n    value: function connect(params) {\n      var _this5 = this;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = params;\n      }\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n      this.conn.onopen = function () {\n        return _this5.onConnOpen();\n      };\n      this.conn.onerror = function (error) {\n        return _this5.onConnError(error);\n      };\n      this.conn.onmessage = function (event) {\n        return _this5.onConnMessage(event);\n      };\n      this.conn.onclose = function (event) {\n        return _this5.onConnClose(event);\n      };\n    }\n\n    // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\n    //\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      var _this6 = this;\n\n      this.log(\"transport\", \"connected to \" + this.endPointURL(), this.transport.prototype);\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this6.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n        case SOCKET_STATES.open:\n          return \"open\";\n        case SOCKET_STATES.closing:\n          return \"closing\";\n        default:\n          return \"closed\";\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return !c.isMember(channel.topic);\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this7 = this;\n\n      var topic = data.topic;\n      var event = data.event;\n      var payload = data.payload;\n      var ref = data.ref;\n\n      var callback = function callback() {\n        return _this7.conn.send(JSON.stringify(data));\n      };\n      this.log(\"push\", topic + \" \" + event + \" (\" + ref + \")\", payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n\n    // Return the next message ref, accounting for overflows\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n      this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef() });\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var msg = JSON.parse(rawMessage.data);\n      var topic = msg.topic;\n      var event = msg.event;\n      var payload = msg.payload;\n      var ref = msg.ref;\n\n      this.log(\"receive\", (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\n      this.channels.filter(function (channel) {\n        return channel.isMember(topic);\n      }).forEach(function (channel) {\n        return channel.trigger(event, payload, ref);\n      });\n      this.stateChangeCallbacks.message.forEach(function (callback) {\n        return callback(msg);\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nvar LongPoll = exports.LongPoll = function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: \"normalizeEndpoint\",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: \"endpointURL\",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n    }\n  }, {\n    key: \"closeAndRetry\",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: \"ontimeout\",\n    value: function ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this8 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status;\n          var token = resp.token;\n          var messages = resp.messages;\n\n          _this8.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              return _this8.onmessage({ data: JSON.stringify(msg) });\n            });\n            _this8.poll();\n            break;\n          case 204:\n            _this8.poll();\n            break;\n          case 410:\n            _this8.readyState = SOCKET_STATES.open;\n            _this8.onopen();\n            _this8.poll();\n            break;\n          case 0:\n          case 500:\n            _this8.onerror();\n            _this8.closeAndRetry();\n            break;\n          default:\n            throw \"unhandled poll status \" + status;\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this9 = this;\n\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this9.onerror(status);\n          _this9.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\n\nvar Ajax = exports.Ajax = function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: \"request\",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (window.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var req = window.XMLHttpRequest ? new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n        new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: \"xdomainRequest\",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this10 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n      req.onload = function () {\n        var response = _this10.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      // Work around bug in IE9 that requires an attached onprogress handler\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: \"xhrRequest\",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this11 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint, true);\n      req.setRequestHeader(\"Content-Type\", accept);\n      req.onerror = function () {\n        callback && callback(null);\n      };\n      req.onreadystatechange = function () {\n        if (req.readyState === _this11.states.complete && callback) {\n          var response = _this11.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(resp) {\n      return resp && resp !== \"\" ? JSON.parse(resp) : null;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n        var paramKey = parentKey ? parentKey + \"[\" + key + \"]\" : key;\n        var paramVal = obj[key];\n        if ((typeof paramVal === \"undefined\" ? \"undefined\" : _typeof(paramVal)) === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n      return queryStr.join(\"&\");\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\" + url + prefix + this.serialize(params);\n    }\n  }]);\n\n  return Ajax;\n}();\n\nAjax.states = { complete: 4 };\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//    reconnectTimer.scheduleTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//\n\nvar Timer = function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    // Cancels any previous scheduleTimeout and schedules callback\n\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var _this12 = this;\n\n      clearTimeout(this.timer);\n\n      this.timer = setTimeout(function () {\n        _this12.tries = _this12.tries + 1;\n        _this12.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n\n})(typeof(exports) === \"undefined\" ? window.Phoenix = window.Phoenix || {} : exports);\n\n  });","require.register('phoenix_html', function(exports,req,module){\n    var require = __makeRequire((function(n) { return req(n.replace('./', 'phoenix_html/')); }), {});\n    'use strict';\n\n// Although ^=parent is not technically correct,\n// we need to use it in order to get IE8 support.\nvar elements = document.querySelectorAll('[data-submit^=parent]');\nvar len = elements.length;\n\nfor (var i = 0; i < len; ++i) {\n  elements[i].addEventListener('click', function (event) {\n    var message = this.getAttribute(\"data-confirm\");\n    if (message === null || confirm(message)) {\n      this.parentNode.submit();\n    };\n    event.preventDefault();\n    return false;\n  }, false);\n}\n\n;\n  });","// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are multiplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket(\"/ws\", {params: {userToken: \"123\"}})\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket,\n// the authentication params, as well as options that can be found in\n// the Socket docs, such as configuring the `LongPoll` transport, and\n// heartbeat.\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here's an example chat room example where `\"new_msg\"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error/timeout matches:\n//\n//     let channel = socket.channel(\"room:123\", {token: roomToken})\n//     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n//     $input.onEnter( e => {\n//       channel.push(\"new_msg\", {body: e.target.val}, 10000)\n//        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n//        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n//        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n//     })\n//     channel.join()\n//       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n//       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n//       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\n//\n//\n// ## Joining\n//\n// Creating a channel with `socket.channel(topic, params)`, binds the params to\n// `channel.params`, which are sent up on `channel.join()`.\n// Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an \"ok\" status, while unsuccessful joins\n// receive \"error\".\n//\n// ## Duplicate Join Subscriptions\n//\n// While the client may join any number of topics on any number of channels,\n// the client may only hold a single subscription for each unique topic at any\n// given time. When attempting to create a duplicate subscription,\n// the server will close the existing channel, log a warning, and\n// spawn a new channel for the topic. The client will have their\n// `channel.onClose` callbacks fired for the existing channel, and the new\n// channel join will have its receive hooks processed as normal.\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `channel.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n//  and take action after some period of waiting. The default timeout is 5000ms.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\n//     socket.onClose( () => console.log(\"the connection dropped\") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     channel.onError( () => console.log(\"there was an error!\") )\n//     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attempted\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `channel.leave()`\n//\n//\n// ## Presence\n//\n// The `Presence` object provides features for syncing presence information\n// from the server with the client and handling presences joining and leaving.\n//\n// ### Syncing initial state from the server\n//\n// `Presence.syncState` is used to sync the list of presences on the server\n// with the client's state. An optional `onJoin` and `onLeave` callback can\n// be provided to react to changes in the client's local presences across\n// disconnects and reconnects with the server.\n//\n// `Presence.syncDiff` is used to sync a diff of presence join and leave\n// events from the server, as they happen. Like `syncState`, `syncDiff`\n// accepts optional `onJoin` and `onLeave` callbacks to react to a user\n// joining or leaving from a device.\n//\n// ### Listing Presences\n//\n// `Presence.list` is used to return a list of presence information\n// based on the local state of metadata. By default, all presence\n// metadata is returned, but a `listBy` function can be supplied to\n// allow the client to select which metadata to use for a given presence.\n// For example, you may have a user online from different devices with a\n// a metadata status of \"online\", but they have set themselves to \"away\"\n// on another device. In this case, they app may choose to use the \"away\"\n// status for what appears on the UI. The example below defines a `listBy`\n// function which prioritizes the first metadata which was registered for\n// each user. This could be the first tab they opened, or the first device\n// they came online from:\n//\n//     let state = {}\n//     state = Presence.syncState(state, stateFromServer)\n//     let listBy = (id, {metas: [first, ...rest]}) => {\n//       first.count = rest.length + 1 // count of this user's presences\n//       first.id = id\n//       return first\n//     }\n//     let onlineUsers = Presence.list(state, listBy)\n//\n//\n// ### Example Usage\n//\n//     // detect if user has joined for the 1st time or from another tab/device\n//     let onJoin = (id, current, newPres) => {\n//       if(!current){\n//         console.log(\"user has entered for the first time\", newPres)\n//       } else {\n//         console.log(\"user additional presence\", newPres)\n//       }\n//     }\n//     // detect if user has left from all tabs/devices, or is still present\n//     let onLeave = (id, current, leftPres) => {\n//       if(current.metas.length === 0){\n//         console.log(\"user has left from all devices\", leftPres)\n//       } else {\n//         console.log(\"user left from a device\", leftPres)\n//       }\n//     }\n//     let presences = {} // client's initial empty presence state\n//     // receive initial presence data from server, sent after join\n//     myChannel.on(\"presences\", state => {\n//       presences = Presence.syncState(presences, state, onJoin, onLeave)\n//       displayUsers(Presence.list(presences))\n//     })\n//     // receive \"presence_diff\" from server, containing join/leave events\n//     myChannel.on(\"presence_diff\", diff => {\n//       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\n//       this.setState({users: Presence.list(room.presences, listBy)})\n//     })\n//\nconst VSN = \"1.0.0\"\nconst SOCKET_STATES = {connecting: 0, open: 1, closing: 2, closed: 3}\nconst DEFAULT_TIMEOUT = 10000\nconst CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n}\nconst CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n}\nconst TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}\n\nclass Push {\n\n  // Initializes the Push\n  //\n  // channel - The Channel\n  // event - The event, for example `\"phx_join\"`\n  // payload - The payload, for example `{user_id: 123}`\n  // timeout - The push timeout in milliseconds\n  //\n  constructor(channel, event, payload, timeout){\n    this.channel      = channel\n    this.event        = event\n    this.payload      = payload || {}\n    this.receivedResp = null\n    this.timeout      = timeout\n    this.timeoutTimer = null\n    this.recHooks     = []\n    this.sent         = false\n  }\n\n  resend(timeout){\n    this.timeout = timeout\n    this.cancelRefEvent()\n    this.ref          = null\n    this.refEvent     = null\n    this.receivedResp = null\n    this.sent         = false\n    this.send()\n  }\n\n  send(){ if(this.hasReceived(\"timeout\")){ return }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref\n    })\n  }\n\n  receive(status, callback){\n    if(this.hasReceived(status)){\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({status, callback})\n    return this\n  }\n\n\n  // private\n\n  matchReceive({status, response, ref}){\n    this.recHooks.filter( h => h.status === status )\n                 .forEach( h => h.callback(response) )\n  }\n\n  cancelRefEvent(){ if(!this.refEvent){ return }\n    this.channel.off(this.refEvent)\n  }\n\n  cancelTimeout(){\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  startTimeout(){ if(this.timeoutTimer){ return }\n    this.ref      = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {})\n    }, this.timeout)\n  }\n\n  hasReceived(status){\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  trigger(status, response){\n    this.channel.trigger(this.refEvent, {status, response})\n  }\n}\n\nexport class Channel {\n  constructor(topic, params, socket) {\n    this.state       = CHANNEL_STATES.closed\n    this.topic       = topic\n    this.params      = params || {}\n    this.socket      = socket\n    this.bindings    = []\n    this.timeout     = this.socket.timeout\n    this.joinedOnce  = false\n    this.joinPush    = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer  = []\n    this.rejoinTimer  = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach( pushEvent => pushEvent.send() )\n      this.pushBuffer = []\n    })\n    this.onClose( () => {\n      this.rejoinTimer.reset()\n      this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError( reason => { if(this.isLeaving() || this.isClosed()){ return }\n      this.socket.log(\"channel\", `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive(\"timeout\", () => { if(!this.isJoining()){ return }\n      this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  rejoinUntilConnected(){\n    this.rejoinTimer.scheduleTimeout()\n    if(this.socket.isConnected()){\n      this.rejoin()\n    }\n  }\n\n  join(timeout = this.timeout){\n    if(this.joinedOnce){\n      throw(`tried to join multiple times. 'join' can only be called a single time per channel instance`)\n    } else {\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  onClose(callback){ this.on(CHANNEL_EVENTS.close, callback) }\n\n  onError(callback){\n    this.on(CHANNEL_EVENTS.error, reason => callback(reason) )\n  }\n\n  on(event, callback){ this.bindings.push({event, callback}) }\n\n  off(event){ this.bindings = this.bindings.filter( bind => bind.event !== event ) }\n\n  canPush(){ return this.socket.isConnected() && this.isJoined() }\n\n  push(event, payload, timeout = this.timeout){\n    if(!this.joinedOnce){\n      throw(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if(this.canPush()){\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  // Leaves the channel\n  //\n  // Unsubscribes from server events, and\n  // instructs channel to terminate on server\n  //\n  // Triggers onClose() hooks\n  //\n  // To receive leave acknowledgements, use the a `receive`\n  // hook to bind to the server ack, ie:\n  //\n  //     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n  //\n  leave(timeout = this.timeout){\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      this.socket.log(\"channel\", `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, \"leave\", this.joinRef())\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive(\"ok\", () => onClose() )\n             .receive(\"timeout\", () => onClose() )\n    leavePush.send()\n    if(!this.canPush()){ leavePush.trigger(\"ok\", {}) }\n\n    return leavePush\n  }\n\n  // Overridable message hook\n  //\n  // Receives all events for specialized message handling\n  // before dispatching to the channel callbacks.\n  //\n  // Must return the payload, modified or unmodified\n  onMessage(event, payload, ref){ return payload }\n\n  // private\n\n  isMember(topic){ return this.topic === topic }\n\n  joinRef(){ return this.joinPush.ref }\n\n  sendJoin(timeout){\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  rejoin(timeout = this.timeout){ if(this.isLeaving()){ return }\n    this.sendJoin(timeout)\n  }\n\n  trigger(event, payload, ref){\n    let {close, error, leave, join} = CHANNEL_EVENTS\n    if(ref && [close, error, leave, join].indexOf(event) >= 0 && ref !== this.joinRef()){\n      return\n    }\n    let handledPayload = this.onMessage(event, payload, ref)\n    if(payload && !handledPayload){ throw(\"channel onMessage callbacks must return the payload, modified or unmodified\") }\n\n    this.bindings.filter( bind => bind.event === event)\n                 .map( bind => bind.callback(handledPayload, ref))\n  }\n\n  replyEventName(ref){ return `chan_reply_${ref}` }\n\n  isClosed() { return this.state === CHANNEL_STATES.closed }\n  isErrored(){ return this.state === CHANNEL_STATES.errored }\n  isJoined() { return this.state === CHANNEL_STATES.joined }\n  isJoining(){ return this.state === CHANNEL_STATES.joining }\n  isLeaving(){ return this.state === CHANNEL_STATES.leaving }\n}\n\nexport class Socket {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\n  //                                               \"wss://example.com\"\n  //                                               \"/ws\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n  //               Defaults to WebSocket with automatic LongPoll fallback.\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n  constructor(endPoint, opts = {}){\n    this.stateChangeCallbacks = {open: [], close: [], error: [], message: []}\n    this.channels             = []\n    this.sendBuffer           = []\n    this.ref                  = 0\n    this.timeout              = opts.timeout || DEFAULT_TIMEOUT\n    this.transport            = opts.transport || window.WebSocket || LongPoll\n    this.heartbeatIntervalMs  = opts.heartbeatIntervalMs || 30000\n    this.reconnectAfterMs     = opts.reconnectAfterMs || function(tries){\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000\n    }\n    this.logger               = opts.logger || function(){} // noop\n    this.longpollerTimeout    = opts.longpollerTimeout || 20000\n    this.params               = opts.params || {}\n    this.endPoint             = `${endPoint}/${TRANSPORTS.websocket}`\n    this.reconnectTimer       = new Timer(() => {\n      this.disconnect(() => this.connect())\n    }, this.reconnectAfterMs)\n  }\n\n  protocol(){ return location.protocol.match(/^https/) ? \"wss\" : \"ws\" }\n\n  endPointURL(){\n    let uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params), {vsn: VSN})\n    if(uri.charAt(0) !== \"/\"){ return uri }\n    if(uri.charAt(1) === \"/\"){ return `${this.protocol()}:${uri}` }\n\n    return `${this.protocol()}://${location.host}${uri}`\n  }\n\n  disconnect(callback, code, reason){\n    if(this.conn){\n      this.conn.onclose = function(){} // noop\n      if(code){ this.conn.close(code, reason || \"\") } else { this.conn.close() }\n      this.conn = null\n    }\n    callback && callback()\n  }\n\n  // params - The params to send when connecting, for example `{user_id: userToken}`\n  connect(params){\n    if(params){\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\")\n      this.params = params\n    }\n    if(this.conn){ return }\n\n    this.conn = new this.transport(this.endPointURL())\n    this.conn.timeout   = this.longpollerTimeout\n    this.conn.onopen    = () => this.onConnOpen()\n    this.conn.onerror   = error => this.onConnError(error)\n    this.conn.onmessage = event => this.onConnMessage(event)\n    this.conn.onclose   = event => this.onConnClose(event)\n  }\n\n  // Logs the message. Override `this.logger` for specialized logging. noops by default\n  log(kind, msg, data){ this.logger(kind, msg, data) }\n\n  // Registers callbacks for connection state change events\n  //\n  // Examples\n  //\n  //    socket.onError(function(error){ alert(\"An error occurred\") })\n  //\n  onOpen     (callback){ this.stateChangeCallbacks.open.push(callback) }\n  onClose    (callback){ this.stateChangeCallbacks.close.push(callback) }\n  onError    (callback){ this.stateChangeCallbacks.error.push(callback) }\n  onMessage  (callback){ this.stateChangeCallbacks.message.push(callback) }\n\n  onConnOpen(){\n    this.log(\"transport\", `connected to ${this.endPointURL()}`, this.transport.prototype)\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    if(!this.conn.skipHeartbeat){\n      clearInterval(this.heartbeatTimer)\n      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n    }\n    this.stateChangeCallbacks.open.forEach( callback => callback() )\n  }\n\n  onConnClose(event){\n    this.log(\"transport\", \"close\", event)\n    this.triggerChanError()\n    clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach( callback => callback(event) )\n  }\n\n  onConnError(error){\n    this.log(\"transport\", error)\n    this.triggerChanError()\n    this.stateChangeCallbacks.error.forEach( callback => callback(error) )\n  }\n\n  triggerChanError(){\n    this.channels.forEach( channel => channel.trigger(CHANNEL_EVENTS.error) )\n  }\n\n  connectionState(){\n    switch(this.conn && this.conn.readyState){\n      case SOCKET_STATES.connecting: return \"connecting\"\n      case SOCKET_STATES.open:       return \"open\"\n      case SOCKET_STATES.closing:    return \"closing\"\n      default:                       return \"closed\"\n    }\n  }\n\n  isConnected(){ return this.connectionState() === \"open\" }\n\n  remove(channel){\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef())\n  }\n\n  channel(topic, chanParams = {}){\n    let chan = new Channel(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  push(data){\n    let {topic, event, payload, ref} = data\n    let callback = () => this.conn.send(JSON.stringify(data))\n    this.log(\"push\", `${topic} ${event} (${ref})`, payload)\n    if(this.isConnected()){\n      callback()\n    }\n    else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  // Return the next message ref, accounting for overflows\n  makeRef(){\n    let newRef = this.ref + 1\n    if(newRef === this.ref){ this.ref = 0 } else { this.ref = newRef }\n\n    return this.ref.toString()\n  }\n\n  sendHeartbeat(){ if(!this.isConnected()){ return }\n    this.push({topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef()})\n  }\n\n  flushSendBuffer(){\n    if(this.isConnected() && this.sendBuffer.length > 0){\n      this.sendBuffer.forEach( callback => callback() )\n      this.sendBuffer = []\n    }\n  }\n\n  onConnMessage(rawMessage){\n    let msg = JSON.parse(rawMessage.data)\n    let {topic, event, payload, ref} = msg\n    this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload)\n    this.channels.filter( channel => channel.isMember(topic) )\n                 .forEach( channel => channel.trigger(event, payload, ref) )\n    this.stateChangeCallbacks.message.forEach( callback => callback(msg) )\n  }\n}\n\n\nexport class LongPoll {\n\n  constructor(endPoint){\n    this.endPoint        = null\n    this.token           = null\n    this.skipHeartbeat   = true\n    this.onopen          = function(){} // noop\n    this.onerror         = function(){} // noop\n    this.onmessage       = function(){} // noop\n    this.onclose         = function(){} // noop\n    this.pollEndpoint    = this.normalizeEndpoint(endPoint)\n    this.readyState      = SOCKET_STATES.connecting\n\n    this.poll()\n  }\n\n  normalizeEndpoint(endPoint){\n    return(endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll))\n  }\n\n  endpointURL(){\n    return Ajax.appendParams(this.pollEndpoint, {token: this.token})\n  }\n\n  closeAndRetry(){\n    this.close()\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout(){\n    this.onerror(\"timeout\")\n    this.closeAndRetry()\n  }\n\n  poll(){\n    if(!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)){ return }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if(resp){\n        var {status, token, messages} = resp\n        this.token = token\n      } else{\n        var status = 0\n      }\n\n      switch(status){\n        case 200:\n          messages.forEach( msg => this.onmessage({data: JSON.stringify(msg)}) )\n          this.poll()\n          break\n        case 204:\n          this.poll()\n          break\n        case 410:\n          this.readyState = SOCKET_STATES.open\n          this.onopen()\n          this.poll()\n          break\n        case 0:\n        case 500:\n          this.onerror()\n          this.closeAndRetry()\n          break\n        default: throw(`unhandled poll status ${status}`)\n      }\n    })\n  }\n\n  send(body){\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if(!resp || resp.status !== 200){\n        this.onerror(status)\n        this.closeAndRetry()\n      }\n    })\n  }\n\n  close(code, reason){\n    this.readyState = SOCKET_STATES.closed\n    this.onclose()\n  }\n}\n\n\nexport class Ajax {\n\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback){\n    if(window.XDomainRequest){\n      let req = new XDomainRequest() // IE8, IE9\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else {\n      let req = window.XMLHttpRequest ?\n                  new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n                  new ActiveXObject(\"Microsoft.XMLHTTP\") // IE6, IE5\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback)\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => {}\n\n    req.send(body)\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint, true)\n    req.setRequestHeader(\"Content-Type\", accept)\n    req.onerror = () => { callback && callback(null) }\n    req.onreadystatechange = () => {\n      if(req.readyState === this.states.complete && callback){\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    req.send(body)\n  }\n\n  static parseJSON(resp){\n    return (resp && resp !== \"\") ?\n             JSON.parse(resp) :\n             null\n  }\n\n  static serialize(obj, parentKey){\n    let queryStr = [];\n    for(var key in obj){ if(!obj.hasOwnProperty(key)){ continue }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if(typeof paramVal === \"object\"){\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join(\"&\")\n  }\n\n  static appendParams(url, params){\n    if(Object.keys(params).length === 0){ return url }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\"\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n\nAjax.states = {complete: 4}\n\n\n\nexport var Presence = {\n\n  syncState(currentState, newState, onJoin, onLeave){\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if(!newState[key]){\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if(currentPresence){\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if(joinedMetas.length > 0){\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if(leftMetas.length > 0){\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, {joins: joins, leaves: leaves}, onJoin, onLeave)\n  },\n\n  syncDiff(currentState, {joins, leaves}, onJoin, onLeave){\n    let state = this.clone(currentState)\n    if(!onJoin){ onJoin = function(){} }\n    if(!onLeave){ onLeave = function(){} }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = newPresence\n      if(currentPresence){\n        state[key].metas.unshift(...currentPresence.metas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if(!currentPresence){ return }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if(currentPresence.metas.length === 0){\n        delete state[key]\n      }\n    })\n    return state\n  },\n\n  list(presences, chooser){\n    if(!chooser){ chooser = function(key, pres){ return pres } }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  },\n\n  // private\n\n  map(obj, func){\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  },\n\n  clone(obj){ return JSON.parse(JSON.stringify(obj)) }\n}\n\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//    reconnectTimer.scheduleTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//\nclass Timer {\n  constructor(callback, timerCalc){\n    this.callback  = callback\n    this.timerCalc = timerCalc\n    this.timer     = null\n    this.tries     = 0\n  }\n\n  reset(){\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout(){\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n","// Brunch automatically concatenates all files in your\n// watched paths. Those paths can be configured at\n// config.paths.watched in \"brunch-config.js\".\n//\n// However, those files will only be executed if\n// explicitly imported. The only exception are files\n// in vendor, which are never wrapped in imports and\n// therefore are always executed.\n\n// Import dependencies\n//\n// If you no longer want to use a dependency, remember\n// to also remove its path from \"config.paths.watched\".\nimport \"phoenix_html\"\n\n// Import local files\n//\n// Local files can be imported directly using relative\n// paths \"./socket\" or full ones \"web/static/js/socket\".\n\n// import socket from \"./socket\"\n","// NOTE: The contents of this file will only be executed if\n// you uncomment its entry in \"web/static/js/app.js\".\n\n// To use Phoenix channels, the first step is to import Socket\n// and connect at the socket path in \"lib/my_app/endpoint.ex\":\nimport {Socket} from \"phoenix\"\n\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}})\n\n// When you connect, you'll often need to authenticate the client.\n// For example, imagine you have an authentication plug, `MyAuth`,\n// which authenticates the session and assigns a `:current_user`.\n// If the current user exists you can assign the user's token in\n// the connection for use in the layout.\n//\n// In your \"web/router.ex\":\n//\n//     pipeline :browser do\n//       ...\n//       plug MyAuth\n//       plug :put_user_token\n//     end\n//\n//     defp put_user_token(conn, _) do\n//       if current_user = conn.assigns[:current_user] do\n//         token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\n//         assign(conn, :user_token, token)\n//       else\n//         conn\n//       end\n//     end\n//\n// Now you need to pass this token to JavaScript. You can do so\n// inside a script tag in \"web/templates/layout/app.html.eex\":\n//\n//     <script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\n//\n// You will need to verify the user token in the \"connect/2\" function\n// in \"web/channels/user_socket.ex\":\n//\n//     def connect(%{\"token\" => token}, socket) do\n//       # max_age: 1209600 is equivalent to two weeks in seconds\n//       case Phoenix.Token.verify(socket, \"user socket\", token, max_age: 1209600) do\n//         {:ok, user_id} ->\n//           {:ok, assign(socket, :user, user_id)}\n//         {:error, reason} ->\n//           :error\n//       end\n//     end\n//\n// Finally, pass the token on connect as below. Or remove it\n// from connect if you don't care about authentication.\n\nsocket.connect()\n\n// Now that you are connected, you can join channels with a topic:\nlet channel = socket.channel(\"topic:subtopic\", {})\nchannel.join()\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) })\n\nexport default socket\n"]}